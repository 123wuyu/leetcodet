### 1.复制集

* 不同的机器之间，数据相互备份。每个机器上都是一份完整的数据。
* 作用：复制集解决数据的**高可用**问题。避免因为单机故障，影响数据的使用。

### 2.分布式

* 不同的机器中，分散保存数据，全部机器上的数据合在一起，才是一份完整的数据。
* 作用：分布式解决数据的**高吞吐**问题。避免因为访问量过大，影响单机的性能。
* redis 的分布式，自带复制集。
* mysql 的复制集可以多主多从，redis的复制集只能一主多从



* 集群和分布式：
  * 不是一个概念；
  * 集群：多台机器共同做一个事情，每台机器做的事情是一样。部署时候用负载均衡。
  * 分布式：一个事情，拆成不同的子任务，让多台机器共同做，每台机器做的事情是不一样的，是不同的子任务。部署时候要拆成不同模块去部署。
  * 多台机器不一定是分布式，分布式一定是多台机器。
  * 集群不一定是分布式，分布式一定是集群。

### 3.分库分表

为什么要分库分表？

* 请求量大
* 单库数据量大，根据磁盘和数据库引擎决定
* 单表数据量大，1000万记录可以考虑分表

怎么分？

先垂直分，再水平分。

* 水平分表：
  * 针对数据量巨大的单张表（比如订单表），按照某种规则（比如日期、地理位置等），切分到多张表里面去。
  *  但是水平分表的这些表还是在同一个库中，所以库级别的数据库操作还是有IO瓶颈。不建议采用，一般用水平分库分表。
* 水平分库分表：
  * 将单张表的数据切分到多个服务器上去，每个服务器具有相应的库与表，只是表中数据集合不同。
  * 水平分库分表能够有效的缓解单机单库的性能瓶颈。
* 垂直分表：
  * 垂直分表，也就是大表拆小表。适用于字段太多，查询效率较低的情况。
* 垂直分库：
  * 垂直分库针对的是一个系统中按不同业务进行拆分，比如用户User一个库，商品Producet一个库，订单Order一个库。切分后，放在多个服务器上。
  * 数据库是最容易成为系统的瓶颈。数据库的连接资源比较宝贵且单机处理能力也有限，在高并发场景下，垂直分库能在一定程度上突破单机硬件资源的瓶颈。

### 4.分布式id

* 分布式id，如果一共是3台机器，单台机器数据库主键可以自增和唯一，但是一个项目的主键id必须要求唯一和自增，
  * **需求：多台机器数据库主键可以自增和唯一**
  * 1、UUID：只能做到唯一。16进制数据，有字符串，不自增。
  * 2、利用一台mysql，只负责生产id。有单机故障问题。
  * 3、利用 redis 的自增功能来生成主键id。因为Redis是单线程的所以能保证原子性。有单机故障问题。
  * 选择雪花算法
    * **雪花算法**=符号位+时间戳+机器码+序列号
    * 雪花算法生成一个64bit的整数。
    * 时钟回拨：因为机器的原因会发生时间回拨。雪花算法是强依赖我们的时间的，如果时间发生回拨，有可能会生成重复的ID
    * 时钟回拨解决办法：用当前时间和上一次的时间进行比较判断。如果当前时间小于上一次的时间那么肯定是发生了回拨，算法会直接抛出异常.

### 5.sql语句优化：

* 避免全表扫描，应考虑在 where 条件 和 order by 排序涉及的列上建立索引；大多数的全表扫描是因为没加索引导致。
* SQL语句尽量大写。对于小写的sql语句，数据库在解析sql语句时，通常是先转换成大写再执行。
* 尽量避免在 where 子句中使用!=或<>操作符。因为MySQL对 不等号 不使用索引
* 遵循最左原则，在where子句中写查询条件时把索引字段放在前面
* 能使用关联查询解决的尽量不要使用子查询(子查询就是sql嵌套)
* 使用LIMIT来限制数据。不需要获取全表数据的时候，就不要查询全表数据，使用LIMIT来限制数据。
* 生产环境下禁止使用select *。

### 6. 数据库优化：

- 反范式设计。在进行表设计时，可适度增加冗余字段，减少JOIN操作；
- 分库分表。多字段的表可以进行垂直分表优化，多数据的表可以进行水平分库分表优化；
- 选择恰当的数据类型。如整型的选择。
- 不同的表使用不同的数据库引擎。对于强调快速读取操作的表，可以使用**MyISAM**数据库引擎；对于强调事务操作的表，使用**InnoDB**数据库引擎。
  （不同的引擎，维护的索引是不一样的。）MyISAM和InnoDB存储引擎B+Tree，本质上二叉树，，InnoDB的数据文件本身就是索引文件。而MyISAM的索引和数据是分开的。
- 建索引。对于查询频繁的字段创建索引，对于更新频繁的字段不适合用索引。
- 使用慢查询工具找出效率低下的SQL语句进行优化；
- 系统架构层面：构建缓存，减少数据库磁盘操作

### 7.redis

* 事务：
  * multi表示开启事务
  * exec表示执行事务
  * 在Redis的Python 客户端库中使用pipeline 管道，作用是：
    - 在客户端统一收集操作指令
    - 补充上multi和exec指令，当作一个事务发送到redis服务器执行

* watch:

  * 表示监视数据，类似于 乐观锁
  * 如果在watch之后，数据发生了变化，事务不会执行。

* redis-cluster不支持事务。

* 持久化：

  * redis特点：k/v形式、内存存储、nosql、持久化。单进程单线程
  * 概念：redis数据库默认支持持久化，把内存里的数据存入磁盘中；

  * 两种：

    * RDB：默认开启，快照，redis数据库默认支持的持久化方案；

      * 手动触发快照bgsave、shutdown

    * AOF：默认不开启，追加文件，保存对redis的所有写操作；重写rewrite，默认情况下64M后，会启动压缩；

      ~~~python
      # appendfsync always 对磁盘io性能会有影响，因为每次写操作都会保存到文件中
      appendfsync everysec # 每秒保存一次
      # appendfsync no # 由操作系统决定什么时候保存到文件，Linux30秒会把缓存写入文件。
      ~~~

    * 结论：两种配合使用，最坏情况下，会丢失1秒之内的数据。

### 8.redis高可用

* 哨兵机制：
  * 负责看管redis运行的实例，哨兵本身会和运行的redis实例进行数据通信，心跳机制；
  * redis集群 默认开启哨兵
  * 哨兵要分散运行在独立的机器上。
  * 哨兵的开启是个奇数(至少三个以上)。因为有投票机制，少数服从多数。



* redis主从的作用：持久存储
* redis分布式的作用：缓存
* redis 默认16384 个slot 槽位



