### 1.复制集

* 不同的机器之间，数据相互备份。每个机器上都是一份完整的数据。
* 作用：复制集解决数据的**高可用**问题。避免因为单机故障，影响数据的使用。

### 2.分布式

* 不同的机器中，分散保存数据，全部机器上的数据合在一起，才是一份完整的数据。
* 作用：分布式解决数据的**高吞吐**问题。避免因为访问量过大，影响单机的性能。
* redis 的分布式，自带复制集。
* mysql 的复制集可以多主多从，redis的复制集只能一主多从



* 集群和分布式：
  * 不是一个概念；
  * 集群：多台机器共同做一个事情，每台机器做的事情是一样。
  * 分布式：一个事情，让多台机器共同做，每台机器做事情是不一样。
  * 多台机器不一定是分布式，分布式一定是多台机器。

### 3.分库分表

* 请求量大
* 单库数据量大，根据磁盘和数据库引擎决定
* 单表数据量大，1000万记录可以考虑分表，
* 水平分库分表：
  * 拆分表，表放入不同的库。
  * 水平分表，拆分数据。数据库太大，取余 26 %2 = 0
* 垂直拆分：
  * 垂直分表，字段太多，查询效率较低。

* 分布式id，如果一共是3台机器，单台机器数据库主键可以自增和唯一，但是一个项目的主键id必须要求唯一和自增，
  * **需求：多台机器数据库主键可以自增和唯一**
  * 1、UUID：只能做到唯一，16进制数据，有字符串，不自增。
  * 2、利用一台mysql，只负责生产id，单机故障。
  * 3、利用redis 的自增功能来生成主键id，单机故障。
  * 时间戳+机器码+序号=**雪花算法**
    * 时钟回拨；

### 4.sql语句优化：

* 避免全表扫描
* 禁止使用select *，生产环境下；
* SQL语句尽量大写
* 尽量避免在 where 子句中使用!=或<>操作符
* 遵循最左原则，在where子句中写查询条件时把索引字段放在前面
* 能使用关联查询解决的尽量不要使用子查询
* 能不使用关联查询的尽量不要使用关联查询；
* 不需要获取全表数据的时候，不要查询全表数据，使用LIMIT来限制数据

### 5.redis

* 事务：
  * multi表示开启事务
  * exec表示执行事务

* watch:

  * 表示监视数据，类似于乐观锁，如果在watch之后，数据发生了变化，事务不会执行。

* redis-cluster不支持事务。

* 持久化：

  * redis特点：k/v形式、内存存储、nosql、持久化。单进程单线程
  * 概念：能通过代码把内存里的数据存入磁盘中；redis数据库默认支持的持久化。

  * 两种：

    * RDB：默认开启，快照，redis数据库默认支持的持久化方案；

      * 手动触发快照bgsave、shutdown

    * AOF：默认不开启，追加文件，保存对redis的所有写操作；重写rewrite，默认情况下64M后，会启动压缩；

      ~~~python
      # appendfsync always 对磁盘io性能会有影响，因为每次写操作都会保存到文件中
      appendfsync everysec # 每秒保存一次
      # appendfsync no # 由操作系统决定什么时候保存到文件，Linux30秒会把缓存写入文件。
      ~~~

      

    * 结论：两种配合使用，最坏情况下，会丢失1秒之内的数据。

### 6.redis高可用

* 哨兵机制：
  * 负责看管redis运行的实例，哨兵本身会和运行的redis实例进行数据通信，心跳机制；
  * 哨兵一般情况下，运行在独立的机器上。
  * 哨兵的开启是个奇数，投票机制，少数服从多数。



* redis主从作用：持久存储
* redis分布式作用：缓存



