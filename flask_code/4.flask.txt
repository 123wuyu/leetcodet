一、flask介绍：
1.Flask是一个轻量级web框架，扩展性强。eg Flask-SQLalchemy：操作数据库；Flask-RESTful：开发REST API；
2.Flask有两个依赖：Werkzeug WSGI工具箱， jinja2模板引擎。
3.Flask是 MVC（模型-视图-控制器）设计模式。
MVC（模型-视图-控制器）设计模式，核心思想是分工、解耦，让不同的代码块之间降低耦合，增强代码的可扩展性和可移植性，实现向后兼容。
flask的mvc中，
M全拼为Model，模型，数据操作层，主要封装对数据库层的访问，对数据库进行增、删、改、查操作。
V全拼为View，视图，用户界面视图层，用于封装结果，生成页面展示的html内容。
C全拼为Controller，控制器，业务逻辑层，用于处理业务逻辑，与Model和View交互。
MVC最大的优点是，实现了后端的分层开发。

二 、flask和django 框架的特点、异同、应用场景？
Django，是一个重量级web框架，集成度高。eg 自带ORM、CSRF中间件、admin管理后台等。适合做企业级大中型网站的开发。
Flask，是一个轻量级web框架，扩展性强。eg Flask-SQLalchemy：操作数据库；Flask-RESTful：开发REST API。一般用于小微项目的开发。


三、flask使用之 hello world：

from flask import Flask

app = Flask(__name__)    #Flask类接收参数__name__，表示flask程序所在的包名或模块名。当文件独立运行时，__name__等于'__main__';当文件被导入其他文件运行时，__name__等于文件名

@app.route('/')    # 装饰器的作用是将路由映射到视图函数上
def index():
    return 'Hello World'


四、flask加载配置信息的三种方式：
1. 加载配置对象。    app.config.from_object(DefaultConfig)
封装性好，可继承，复用性强，但是不安全。一般用于存储业务相关的配置信息，比如数据库连接信息
2. 加载配置文件。    app.config.from_pyfile('settings.py')
不安全。
3. 加载环境变量。    app.config.from_envvar('SET', silent=True)    silent=True，沉默，加载不到不报错
使用相对复杂，但是更安全。一般用于存储?感信息和不对外公开的信息，比如密钥、签名等；


五、设置flask启动的环境变量？
先在 flask shell 中设置环境变量，再 flask run 启动
export 变量名=变量值    # export 暴露环境变量名
export FLASK_APP=hello.py
export FLASK_ENV=development
linux 是export， windows是 set

六、路由函数：
url_for( )函数：
url_for( )函数，用来生成url，它接收的第一个参数是端点值。端点值 就是视图函数的函数名。
在py脚本里，url_for() 需要从 flask 中导包再使用，而在模板中可以直接使用。因为flask把一些常用函数和对象添加到了模板的上下文环境。
eg return redirect(url_for('index'))    # 重定向回主页

查看路由映射
终端中，flask routers
项目中，app.url_map 属性：



七、蓝图？
蓝图，Blueprint，是flask内置的一个模块化处理的类。
作用：在Flask中，使用蓝图Blueprint 来分模块管理。类似django中的子应用。
蓝图使用三步：
from flask import Flask, Blueprint

app = Flask(__name__)

# 1、创建蓝图对象
user_bp = Blueprint('user_bp', __name__)
# 2、定义蓝图路由
@user_bp.route('/')
def user_profile():
    return 'user_profile'
# 3、注册蓝图对象
app.register_blueprint(user_bp)

蓝图的多文件使用：
把使用蓝图对象的视图文件view.py，导入到创建蓝图对象的__init__文件中；
容易发生循环导入的问题。在创建蓝图对象的下面导入视图蓝图对象。



八、处理请求
a. 获取url中的固定参数：
1.  <转换器类型: 形参>    eg <int: num>。
默认是字符串类型
转换器：Flask中默认6种， 整型值、字符串、浮点值、any、path、uuid

2.  自定义转换器：
eg  获取http://127.0.0.1:5000/users/13912345678  中的mobile
- 1.定义转换器类，继承自baseconverter
class RegexMobileConverter(BaseConverter):
    regex = r'1[3-9]\d{9}'

- 2.把自定义的转换器类，添加到转换器字典容器中
app.url_map.converters['mobile'] = RegexMobileConverter

- 3.在装饰器中使用转换器
@app.route('/users/<mobile:temp>')
def regex_mobile(temp):    # 获取到的url中的固定参数，必须传给视图函数
    return 'hello world %s' % temp

b. 获取request请求对象的属性：
mobile = request.args.get("mobile")    # 获取请求中的查询参数
userName = request.form.get('userName')    # 获取请求中的表单数据


九、处理响应：
1. 返回模板渲染     render_template()
2. 返回重定向    return redirect('http://www.baidu.com')
3. 返回json    return jsonify(json_dict)
把数据序列化成json字符串，把响应类型改成 application/json
4. 返回元组(字符串, 状态码, 响应头)
5. make_response() 自定义返回


十、状态保持，cookie和session：
cookie：key/value都存在浏览器中
# cookie设置
@app.route('/set')
def index():
    resp = make_response('set response info')        # 使用make_response生成响应信息
    resp.set_cookie('itcast','python42',max_age=60)        # max_age，单位为秒
    return resp

# cookie获取
@app.route('/get')
def get_cookies():
    # request.cookies，获取cookie信息
    itcast = request.cookies.get('itcast')
    return itcast

session：key存在浏览器中，value存在服务器中。
原生flask没有session。flask是将session存在了浏览器cookie中
# 设置session
app.config['SECRET_KEY'] = '2021'

@app.route('/set')
def index():
    session['itcast'] = 'python42'
    return 'hello world'

# 获取session
@app.route('/get')
def get_session():
    itcast = session.get('itcast')
    return itcast



十一、请求钩子四种
- 请求前执行
  - before_first_request    只执行一次
@app.before_first_request
def first_request():
    print("before first request run")

  - before_request    每次请求前都执行
@app.before_request
def before_request():
    print("before request run")

- 请求后执行
  - after_request    1. 请求后执行  2. 需要接收响应对象为参数
@app.after_request
def after_req(resp):
    print('after request run')
    return resp

  - teardown_request    2.请求后执行，3. 需要接收异常信息e为参数
@app.teardown_request
def teardown_req(e):
    print('teardown request run')



十二、上下文对象
- 请求上下文request_context：
  - request：获取请求信息，比如获取查询字符串 request.args.get()；
  - session：操作用户会话信息，比如 设置session  session['key'] = value, 获取session  session.get('key')
- 应用上下文app_context ：
  - current_app：当前运行的flask app的代理，在代码不方便直接操作flask的app对象时，可以操作current_app。eg 避免循环导包。一般用来获取程序的各种配置信息、记录项目日志
  - g：线程内的全局对象，用于请求过程中临时存储数据。实现了函数之间的数据传递。
- 生命周期：current_app生命周期最长，request和g在请求后会被销毁，session根据会话的有效期决定

- 应用场景：当代码没有运行时，我们可以通过手动开启上下文，获取程序相关信息和数据，一般用来测试代码；
- 手动开启应用上下文：with app.app_context():
- 手动开启请求上下文：with app.request_context(请求的环境数据信息 字典类型):






六、SQLAlchemy的 URI 连接方式：eg ：
mysql://user:password@localhost/mydatabase
user = User(mobile='15612345678', name='zhangsan')
db.session.add(user)
db.session.commit()

九、简述Flask上下文管理流程?
flask 提供两种上下文： 请求上下文 request context 和 应用上下文 application context 。
request context 请求上下文包括 request 和 session。
application context 应用上下文包括 current_app 和 g 两个对象。
current_app 就是当前运行的flask app，在代码不方便直接操作flask的app对象时，可以操作current_app
g 作为 flask 程序全局的一个临时变量，充当中间媒介的作用，我们可以通过它在一次请求调用的多个函数间传递一些数据。每次请求都会重设这个变量。
